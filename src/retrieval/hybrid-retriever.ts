// src/services/HybridRetriever.ts
import { searchService, SearchQuery } from '../services/search.service';
import { schemaService } from '../services/schema.service';
import { logger } from '../core/logger';
import { RetrievedData, DetectedEntity } from '../types';
import { queryEnhancer, EnhancedQuery } from '../services/QueryEnhancerService';

export interface RetrievalOptions {
  userId: string;
  entities: DetectedEntity[];
  collections?: string[];
  limit?: number;
  sort?: Record<string, any>;
  includeRelated?: boolean;
  flattenResults?: boolean;
}

export class HybridRetriever {

  /**
   * Retrieve using planner's query directly (preferred method)
   * This uses the MongoDB query generated by the planner without re-parsing
   */
  async retrieveWithPlan(
    plannerQuery: Record<string, any>,
    collection: string,
    userId: string,
    options: {
      limit?: number;
      sort?: Record<string, any>;
      includeRelated?: boolean;
    } = {}
  ): Promise<RetrievedData[]> {
    const { limit = 20, sort, includeRelated = false } = options;
    
    logger.info('Retrieving with planner query', {
      collection,
      userId,
      queryKeys: Object.keys(plannerQuery),
      query: JSON.stringify(plannerQuery),
      limit,
      hasSort: !!sort
    });

    const schema = schemaService.getSchema(collection);
    if (!schema) {
      logger.warn(`Schema not found for collection: ${collection}`);
      return [];
    }

    // Sanitize and validate the planner's query
    const sanitizedQuery = this.sanitizePlannerQuery(plannerQuery, collection, userId, schema);
    
    logger.debug('MongoDB query details', {
      collection,
      originalQuery: JSON.stringify(plannerQuery),
      sanitizedQuery: JSON.stringify(sanitizedQuery),
      limit,
      sort: JSON.stringify(sort || {})
    });
    
    // Execute search with planner's query
    const searchQuery: SearchQuery = {
      collection,
      userId,
      filter: sanitizedQuery,
      limit,
      sort,
      textQuery: undefined, // Don't use text search when we have planner query
      vectorQuery: undefined
    };

    try {
      const searchResult = await searchService.search(searchQuery, limit);
      
      const result: RetrievedData = {
        collection,
        documents: searchResult.documents,
        limit,
        sort,
        includeRelated: false,
        metadata: {
          count: searchResult.documents.length,
          searchMethod: searchResult.method,
          confidence: searchResult.confidence
        },
      };

      logger.info('Retrieved data with planner query', {
        collection,
        count: searchResult.documents.length,
        method: searchResult.method,
        mongoQuery: JSON.stringify(sanitizedQuery),
        sampleIds: searchResult.documents.slice(0, 5).map((d: any) => d._id?.toString()),
        sampleNames: searchResult.documents.slice(0, 5).map((d: any) => d.name || d.fullName || 'no-name')
      });

      return [result];
    } catch (error: any) {
      logger.error('Search with planner query failed', {
        collection,
        error: error.message,
        query: JSON.stringify(sanitizedQuery)
      });
      return [];
    }
  }

  /**
   * Sanitize planner query to ensure it's valid for the collection
   */
  private sanitizePlannerQuery(
    plannerQuery: Record<string, any>,
    collection: string,
    userId: string,
    schema: any
  ): Record<string, any> {
    const sanitized: Record<string, any> = {};
    
    // Always ensure userId is present
    if (schema.fields.some((f: any) => f.name === 'userId')) {
      sanitized.userId = userId;
    }

    // Generic terms that should never be filter values
    const genericTerms = new Set([
      'all', 'any', 'every', 'each', 'none', 'some',
      'revenue', 'revenu', 'income', 'sales', 'turnover',
      'employees', 'employee', 'employee count', 'staff', 'people', 'headcount',
      'company', 'companies', 'business', 'businesses',
      'sorted', 'order', 'list', 'top', 'max', 'highest', 'give', 'show', 'get',
      'sector', 'sectors', 'all sectors', 'industry', 'industries',
      'count', 'number', 'amount', 'size', 'total', 'sum', 'average',
      'active', 'experience', 'title', 'job', 'position', 'role',
      'has', 'with', 'by', 'for', 'from', 'to', 'over', 'find'
    ]);

    for (const [key, value] of Object.entries(plannerQuery)) {
      // Skip userId - already handled
      if (key === 'userId') continue;

      // Check if field exists in schema (handle both direct fields and dot-notation nested fields)
      let fieldDef = schema.fields.find((f: any) => f.name === key);
      
      // If not found as direct field, check if it's a nested field (dot notation)
      // For nested fields like "scoringMetrics.fit_score.score", check if parent exists
      if (!fieldDef && key.includes('.')) {
        const parentField = key.split('.')[0];
        const parentFieldDef = schema.fields.find((f: any) => f.name === parentField);
        if (parentFieldDef && (parentFieldDef.type === 'Mixed' || parentFieldDef.type === 'Object')) {
          // Nested field in Mixed/Object type - allow it
          // For nested numeric fields like scoringMetrics.fit_score.score, treat as Number
          const isNestedNumeric = key.includes('score') || key.includes('confidence');
          if (isNestedNumeric) {
            // Allow nested numeric fields - they're valid in MongoDB
            sanitized[key] = value;
            continue;
          }
        }
      }
      
      if (!fieldDef) {
        logger.warn(`Field ${key} not found in collection ${collection} schema, skipping`, { value });
        continue;
      }

      // Handle different value types
      if (typeof value === 'object' && value !== null) {
        // Handle MongoDB operators
        if (value.$in && Array.isArray(value.$in)) {
          // Filter out generic terms from $in arrays
          const filtered = value.$in.filter((item: any) => {
            if (typeof item === 'string') {
              const lowerItem = item.toLowerCase().trim();
              return !genericTerms.has(lowerItem) && lowerItem !== key.toLowerCase();
            }
            return true;
          });
          if (filtered.length > 0) {
            sanitized[key] = { ...value, $in: filtered };
          }
        } else if (value.$regex) {
          // Validate regex value
          const regexStr = String(value.$regex).toLowerCase().trim();
          if (!genericTerms.has(regexStr) && regexStr !== key.toLowerCase()) {
            sanitized[key] = value;
          }
        } else {
          // For other operators ($gt, $lt, $gte, $lte, etc.), validate numeric values
          const hasValidValue = Object.values(value).some(v => {
            if (typeof v === 'number') return true;
            if (typeof v === 'string') {
              const lowerV = v.toLowerCase().trim();
              return !genericTerms.has(lowerV) && !isNaN(parseFloat(v));
            }
            return true;
          });
          if (hasValidValue) {
            sanitized[key] = value;
          }
        }
      } else if (typeof value === 'string') {
        // String values - reject generic terms
        const lowerValue = value.toLowerCase().trim();
        if (genericTerms.has(lowerValue) || lowerValue === key.toLowerCase()) {
          logger.warn(`Rejecting generic term "${value}" for field ${key}`, { collection });
          continue;
        }
        sanitized[key] = value;
      } else if (typeof value === 'number' || typeof value === 'boolean') {
        // Numbers and booleans are always valid
        sanitized[key] = value;
      } else {
        sanitized[key] = value;
      }
    }

    logger.debug('Planner query sanitized', {
      collection,
      originalKeys: Object.keys(plannerQuery).length,
      sanitizedKeys: Object.keys(sanitized).length
    });

    return sanitized;
  }

  async retrieve(
    query: string,
    options: RetrievalOptions
  ): Promise<RetrievedData[]> {
    const { userId, entities, collections, includeRelated = true } = options;
    
    // Enhance query with semantic parser
    const enhancedQuery = queryEnhancer.enhance(query, userId);
    
    logger.info('Starting semantic-enhanced retrieval', {
      query,
      confidence: enhancedQuery.confidence,
      intent: enhancedQuery.intent,
      collections: enhancedQuery.collectionHints
    });
  
    // Use enhanced collections if specified
    const targetCollections = collections || enhancedQuery.collectionHints || ['companies'];
    
    const results: RetrievedData[] = [];
  
    for (const collection of targetCollections) {
      const schema = schemaService.getSchema(collection);
      if (!schema) {
        logger.warn(`Schema not found for collection: ${collection}`);
        continue;
      }
  
      // Build comprehensive filter
      const filter = this.buildComprehensiveFilter(
        enhancedQuery,
        collection,
        userId,
        schema,
        entities
      );
      
      // Execute search
      const searchResult = await this.executeSearch(
        collection,
        filter,
        enhancedQuery,
        userId,
        options
      );
      
      if (searchResult) {
        results.push(searchResult);
      }
    }
  
    // Include related data if requested
    if (includeRelated && results.length > 0) {
      const relatedResults = await this.retrieveRelated(results, userId, enhancedQuery.searchKeywords);
      results.push(...relatedResults);
    }
  
    return results;
  }
  
  private buildComprehensiveFilter(
    enhancedQuery: EnhancedQuery,
    collection: string,
    userId: string,
    schema: any,
    entities: DetectedEntity[]
  ): Record<string, any> {
    const filter: Record<string, any> = {};
    
    // Always add userId for collections that require it
    if (schema.fields.find((f: any) => f.name === 'userId')) {
      filter.userId = userId;
    }
    
    // Start with the enhanced mongo filter
    Object.assign(filter, enhancedQuery.mongoFilter);
    
    // Add entity filters from the query parser
    enhancedQuery.parsed.entities.forEach((entity: any) => {
      if (entity.type === 'company') {
        const nameField = schema.fields.find((f: any) => f.name === 'name');
        if (nameField) {
          filter.name = (entity as any).queryValue || { $regex: entity.value, $options: 'i' };
        }
      } else if (entity.type === 'employee') {
        const fullNameField = schema.fields.find((f: any) => f.name === 'fullName');
        if (fullNameField) {
          filter.fullName = (entity as any).queryValue || { $regex: entity.value, $options: 'i' };
        }
      } else if ((entity.type as string) === 'location') {
        // For location entities, search in multiple fields
        const cityField = schema.fields.find((f: any) => f.name === 'city');
        const countryField = schema.fields.find((f: any) => f.name === 'country');
        
        if (cityField || countryField) {
          if (!filter.$or) filter.$or = [];
          if (cityField) {
            filter.$or.push({ city: { $regex: entity.value, $options: 'i' } });
          }
          if (countryField) {
            filter.$or.push({ country: { $regex: entity.value, $options: 'i' } });
          }
        }
      }
    });
    
    // Add semantic filters for this collection from the parser
    if (enhancedQuery.parsed.filters && enhancedQuery.parsed.filters.length > 0) {
      enhancedQuery.parsed.filters
        .filter((fieldFilter: any) => fieldFilter.collection === collection)
        .forEach((fieldFilter: any) => {
          // Validate field exists in schema
          if (!fieldFilter.field) {
            logger.warn('Filter missing field property', { fieldFilter, collection });
            return;
          }
          
          const fieldDef = schema.fields.find((f: any) => f.name === fieldFilter.field);
          if (fieldDef) {
            filter[fieldFilter.field] = fieldFilter.mongoQuery;
          } else {
            logger.warn(`Field ${fieldFilter.field} not found in collection ${collection} schema`, { fieldFilter });
          }
        });
    }
    
    // Add passed-in entities (from previous steps in RIO graph)
    entities.forEach(entity => {
      if (!entity.field) return;
      
      const fieldDef = schema.fields.find((f: any) => f.name === entity.field);
      if (!fieldDef) return;
      
      // Skip generic phrases
      if (fieldDef.type === 'String') {
        const value = entity.value.toLowerCase();
        const genericPhrases = [
          'has max revenue', 'top companies', 'give top',
          'max revenue sales', 'revenue sales income'
        ];
        
        if (genericPhrases.some(phrase => value.includes(phrase))) {
          return;
        }
      }
      
      // Add entity filter
      if (fieldDef.isArray) {
        filter[entity.field] = { $in: Array.isArray(entity.value) ? entity.value : [entity.value] };
      } else if (fieldDef.type === 'String') {
        filter[entity.field] = { $regex: entity.value, $options: 'i' };
      } else {
        filter[entity.field] = entity.value;
      }
    });
    
    // Clean and validate the filter
    const cleanedFilter = this.cleanAndOptimizeFilter(filter, collection);
    
    logger.debug('Built comprehensive filter', {
      collection,
      filterKeys: Object.keys(cleanedFilter),
      hasEntities: enhancedQuery.parsed.entities.length > 0,
      hasSemanticFilters: enhancedQuery.parsed.filters?.filter((f: any) => f.collection === collection).length || 0
    });
    
    return cleanedFilter;
  }
  
  private async executeSearch(
    collection: string,
    filter: Record<string, any>,
    enhancedQuery: EnhancedQuery,
    userId: string,
    options: RetrievalOptions
  ): Promise<RetrievedData | null> {
    try {
      const searchQuery: SearchQuery = {
        collection,
        userId,
        filter,
        limit: enhancedQuery.limit || options.limit || 10,
        sort: enhancedQuery.sort || options.sort,
        textQuery: enhancedQuery.searchKeywords,
        vectorQuery: enhancedQuery.searchKeywords
      };
  
      const searchResult = await searchService.search(searchQuery, searchQuery.limit);
      
      return {
        collection,
        documents: searchResult.documents,
        limit: searchQuery.limit,
        sort: searchQuery.sort,
        includeRelated: false,
        metadata: {
          count: searchResult.documents.length,
          searchMethod: searchResult.method,
          confidence: searchResult.confidence * enhancedQuery.confidence
        },
      };
      
    } catch (error: any) {
      logger.error('Search execution failed', { 
        collection, 
        error: error.message,
        filter: JSON.stringify(filter) 
      });
      return null;
    }
  }
  
  private cleanAndOptimizeFilter(filter: Record<string, any>, collection: string): Record<string, any> {
    const optimized: Record<string, any> = {};
    const schema = schemaService.getSchema(collection);
    
    if (!schema) return filter;
    
    // Generic terms that should never be used as filter values
    const genericTerms = new Set([
      'all', 'any', 'every', 'each', 'none', 'some',
      'revenue', 'revenu', 'income', 'sales', 'turnover',
      'employees', 'employee', 'employee count', 'staff', 'people', 'headcount',
      'company', 'companies', 'business', 'businesses',
      'sorted', 'order', 'list', 'top', 'max', 'highest', 'give', 'show', 'get',
      'sector', 'sectors', 'all sectors', 'industry', 'industries',
      'count', 'number', 'amount', 'size', 'total', 'sum', 'average',
      'active', 'experience', 'title', 'job', 'position', 'role',
      'has', 'with', 'by', 'for', 'from', 'to'
    ]);
    
    for (const [key, value] of Object.entries(filter)) {
      // Skip userId - it's always valid
      if (key === 'userId') {
        optimized[key] = value;
        continue;
      }
      
      // Check if field exists in schema (handle both direct fields and dot-notation nested fields)
      const fieldDef = schema.fields.find((f: any) => f.name === key);
      
      // If not found as direct field, check if it's a nested field (dot notation)
      // For nested fields like "scoringMetrics.fit_score.score", check if parent exists
      if (!fieldDef && key.includes('.')) {
        const parentField = key.split('.')[0];
        const parentFieldDef = schema.fields.find((f: any) => f.name === parentField);
        if (parentFieldDef && (parentFieldDef.type === 'Mixed' || parentFieldDef.type === 'Object')) {
          // Nested field in Mixed/Object type - allow it
          // For nested numeric fields like scoringMetrics.fit_score.score, treat as Number
          const isNestedNumeric = key.includes('score') || key.includes('confidence');
          if (isNestedNumeric) {
            // Allow nested numeric fields - they're valid in MongoDB
            optimized[key] = value;
            continue;
          }
        }
      }
      
      if (!fieldDef) {
        logger.warn(`Field ${key} not found in collection ${collection} schema, skipping`, { value });
        continue;
      }
      
      // Validate field belongs to this collection (check if field exists in schema fields)
      const fieldExists = schema.fields.some((f: any) => f.name === key);
      if (!fieldExists) {
        logger.warn(`Field ${key} does not exist in collection ${collection}, skipping`, { value });
        continue;
      }
      
      // Handle numeric fields - reject non-numeric strings and generic terms
      if (fieldDef.type === 'number') {
        if (typeof value === 'string') {
          // Check if it's a generic term
          const lowerValue = value.toLowerCase().trim();
          if (genericTerms.has(lowerValue) || 
              lowerValue === key.toLowerCase() || 
              lowerValue.includes(key.toLowerCase())) {
            logger.warn(`Rejecting generic term "${value}" for numeric field: ${key}`, { value, collection });
            continue;
          }
          
          // Try to parse as number
          const numValue = parseFloat(value);
          if (isNaN(numValue)) {
            logger.warn(`Cannot convert string "${value}" to number for field ${key}, skipping`, { value });
            continue;
          }
          optimized[key] = numValue;
        } else if (typeof value === 'object' && value !== null) {
          // Handle MongoDB operators like {$gt: 100}
          const hasValidNumericOperator = Object.keys(value).some(op => {
            const opValue = value[op];
            return typeof opValue === 'number' || 
                   (typeof opValue === 'string' && !isNaN(parseFloat(opValue)) && !genericTerms.has(opValue.toLowerCase()));
          });
          if (hasValidNumericOperator) {
            optimized[key] = value;
          } else {
            logger.warn(`Invalid numeric operator object for field ${key}`, { value });
            continue;
          }
        } else if (typeof value === 'number') {
          optimized[key] = value;
        } else {
          logger.warn(`Invalid type for numeric field ${key}: ${typeof value}`, { value });
          continue;
        }
        continue;
      }
      
      // Handle boolean fields
      if (fieldDef.type === 'boolean') {
        if (typeof value === 'string') {
          const lowerValue = value.toLowerCase().trim();
          if (genericTerms.has(lowerValue)) {
            logger.warn(`Rejecting generic term "${value}" for boolean field: ${key}`, { value });
            continue;
          }
          // Convert string to boolean
          if (lowerValue === 'true' || lowerValue === '1' || lowerValue === 'yes') {
            optimized[key] = true;
          } else if (lowerValue === 'false' || lowerValue === '0' || lowerValue === 'no') {
            optimized[key] = false;
          } else {
            logger.warn(`Cannot convert string "${value}" to boolean for field ${key}, skipping`, { value });
            continue;
          }
        } else if (typeof value === 'boolean') {
          optimized[key] = value;
        } else {
          logger.warn(`Invalid type for boolean field ${key}: ${typeof value}`, { value });
          continue;
        }
        continue;
      }
      
      // Handle string fields - reject generic terms
      if (fieldDef.type === 'string') {
        if (typeof value === 'string') {
          const lowerValue = value.toLowerCase().trim();
          // Reject generic terms
          if (genericTerms.has(lowerValue) || 
              lowerValue === key.toLowerCase() ||
              lowerValue.includes('all ') ||
              lowerValue.startsWith('all ')) {
            logger.warn(`Rejecting generic term "${value}" for string field: ${key}`, { value, collection });
            continue;
          }
          optimized[key] = value;
        } else if (typeof value === 'object' && value !== null) {
          // Handle regex queries
          if (value.$regex) {
            const regexValue = String(value.$regex).toLowerCase().trim();
            if (genericTerms.has(regexValue) || regexValue === key.toLowerCase()) {
              logger.warn(`Rejecting generic term in regex for field ${key}`, { value });
              continue;
            }
            optimized[key] = value;
          } else if (value.$in && Array.isArray(value.$in)) {
            // Filter out generic terms from $in arrays
            const filteredIn = value.$in.filter((item: any) => {
              if (typeof item === 'string') {
                const lowerItem = item.toLowerCase().trim();
                return !genericTerms.has(lowerItem) && lowerItem !== key.toLowerCase();
              }
              return true;
            });
            if (filteredIn.length === 0) {
              logger.warn(`All items filtered out from $in array for field ${key}`, { original: value.$in });
              continue;
            }
            optimized[key] = { ...value, $in: filteredIn };
          } else {
            optimized[key] = value;
          }
        } else {
          optimized[key] = value;
        }
        continue;
      }
      
      // Handle array fields
      if (fieldDef.type === 'array') {
        if (Array.isArray(value)) {
          // Filter out generic terms
          const filtered = value.filter((item: any) => {
            if (typeof item === 'string') {
              const lowerItem = item.toLowerCase().trim();
              return !genericTerms.has(lowerItem) && lowerItem !== key.toLowerCase();
            }
            return true;
          });
          if (filtered.length === 0) {
            logger.warn(`All items filtered out from array for field ${key}`, { original: value });
            continue;
          }
          optimized[key] = filtered;
        } else if (typeof value === 'object' && value !== null) {
          // Handle $in, $all operators
          if (value.$in || value.$all) {
            const operator = value.$in ? '$in' : '$all';
            const filtered = value[operator].filter((item: any) => {
              if (typeof item === 'string') {
                const lowerItem = item.toLowerCase().trim();
                return !genericTerms.has(lowerItem) && lowerItem !== key.toLowerCase();
              }
              return true;
            });
            if (filtered.length === 0) {
              logger.warn(`All items filtered out from ${operator} for field ${key}`, { original: value[operator] });
              continue;
            }
            optimized[key] = { ...value, [operator]: filtered };
          } else {
            optimized[key] = value;
          }
        } else {
          optimized[key] = value;
        }
        continue;
      }
      
      // For other types (object, date, etc.), validate and add
      if (typeof value === 'object' && value !== null) {
        // Handle regex queries
        if (value.$regex) {
          const regexStr = String(value.$regex);
          const lowerRegex = regexStr.toLowerCase().trim();
          // Reject regex patterns that are just generic terms
          if (genericTerms.has(lowerRegex) || lowerRegex === key.toLowerCase()) {
            logger.warn(`Rejecting generic term in regex for field ${key}`, { value });
            continue;
          }
          if (!value.$options) {
            value.$options = 'i';
          }
          // Shorten very long regex patterns
          if (regexStr.length > 100) {
            value.$regex = regexStr.substring(0, 100) + '.*';
          }
          optimized[key] = value;
        } else {
          // For other MongoDB operators, validate nested values
          optimized[key] = value;
        }
      } else {
        optimized[key] = value;
      }
    }
    
    // Limit OR conditions to prevent performance issues
    if (optimized.$or && Array.isArray(optimized.$or) && optimized.$or.length > 5) {
      logger.warn('Too many OR conditions, limiting to 5', { 
        collection, 
        originalCount: optimized.$or.length 
      });
      optimized.$or = optimized.$or.slice(0, 5);
    }
    
    // Remove empty arrays from $in operators
    for (const [key, value] of Object.entries(optimized)) {
      if (typeof value === 'object' && value !== null) {
        if (value.$in && Array.isArray(value.$in) && value.$in.length === 0) {
          delete optimized[key];
        }
      }
    }
    
    logger.debug('Filter cleaned and optimized', {
      collection,
      originalKeys: Object.keys(filter).length,
      optimizedKeys: Object.keys(optimized).length,
      removedKeys: Object.keys(filter).length - Object.keys(optimized).length
    });
    
    return optimized;
  }

  private inferCollections(entities: DetectedEntity[]): string[] {
    const collections = new Set<string>();

    entities.forEach(entity => {
      switch (entity.type) {
        case 'company':
          collections.add('companies');
          collections.add('gtm_intelligence');
          break;
        case 'employee':
          collections.add('employees');
          collections.add('gtm_persona_intelligence');
          break;
        case 'icp_model':
          collections.add('icp_models');
          break;
        case 'session':
          collections.add('sessions');
          break;
        default:
          if (entity.collectionHint) {
            collections.add(entity.collectionHint);
          }
      }
    });

    // Always search companies and employees by default
    if (collections.size === 0) {
      collections.add('companies');
      collections.add('employees');
    }

    return Array.from(collections);
  }

  private async retrieveRelated(
    baseResults: RetrievedData[],
    userId: string,
    query: string
  ): Promise<RetrievedData[]> {
    const relatedResults: RetrievedData[] = [];

    for (const result of baseResults) {
      const relatedCollections = schemaService.getRelatedCollections(result.collection);
      
      for (const relatedCollection of relatedCollections) {
        // Skip if we've already retrieved from this collection
        if (baseResults.some(r => r.collection === relatedCollection)) {
          continue;
        }

        const hoppingPath = schemaService.findHoppingPath(
          result.collection,
          relatedCollection
        );

        if (!hoppingPath) continue;

        try {
          const sourceIds = result.documents.map(doc => doc._id.toString());
          
          if (sourceIds.length === 0) {
            continue;
          }
          
          const relatedDocs = await searchService.hop(
            result.collection,
            sourceIds,
            relatedCollection,
            hoppingPath.via,
            userId
          );

          if (relatedDocs.length > 0) {
            relatedResults.push({
              collection: relatedCollection,
              documents: relatedDocs,
              metadata: {
                count: relatedDocs.length,
                searchMethod: 'metadata',
                confidence: 0.8,
              },
            });
          }
        } catch (error: any) {
          logger.debug('Skipping related collection', { 
            from: result.collection,
            to: relatedCollection,
            error: error.message 
          });
        }
      }
    }

    return relatedResults;
  }

  flattenResults(results: RetrievedData[]): Record<string, any>[] {
    const flattened: Record<string, any>[] = [];

    results.forEach(result => {
      result.documents.forEach(doc => {
        const flat = this.flattenObject(doc, result.collection);
        flattened.push(flat);
      });
    });

    return flattened;
  }

  private flattenObject(
    obj: any,
    prefix: string = '',
    result: Record<string, any> = {}
  ): Record<string, any> {
    for (const key in obj) {
      if (!obj.hasOwnProperty(key)) continue;

      const newKey = prefix ? `${prefix}.${key}` : key;
      const value = obj[key];

      if (value === null || value === undefined) {
        result[newKey] = value;
      } else if (Array.isArray(value)) {
        result[newKey] = value;
        value.forEach((item, index) => {
          if (typeof item === 'object' && item !== null) {
            this.flattenObject(item, `${newKey}[${index}]`, result);
          }
        });
      } else if (typeof value === 'object' && !this.isSpecialObject(value)) {
        this.flattenObject(value, newKey, result);
      } else {
        result[newKey] = value;
      }
    }

    return result;
  }

  private isSpecialObject(obj: any): boolean {
    return (
      obj instanceof Date ||
      obj instanceof RegExp ||
      (obj && obj._bsontype === 'ObjectId') ||
      Buffer.isBuffer(obj)
    );
  }
}

export const hybridRetriever = new HybridRetriever();